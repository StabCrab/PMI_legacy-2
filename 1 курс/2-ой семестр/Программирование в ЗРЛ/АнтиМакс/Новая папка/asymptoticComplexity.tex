\section{Асимптотические и амортизационные оценки}
\begin{notice}
    Здесь мы попытаемся дать чуть более 'алгоритмический' материал, чем тот, что приведён в лекции.
\end{notice}

\begin{definition}
    \textbf{Асимптотическая оценка} - функция от времени, либо ограничивающая снизу $(\Omega(g(n)))$ или сверху $(O(g(n)))$ временную сложность алгоритма, либо совпадающая с ней$(\theta(g(n)))$.
\end{definition}

Нижние  оценки  позволяют  понять,  что  нельзя  реализовать  алгоритм эффективнее, чем полученная нижняя оценка.

Верхние оценки позволяют сделать вывод, что алгоритм будет работать не хуже, чем полученная нижняя оценка.

Оценки  одного  вида  различаются  по  «силе»:  очевидно,  что  для алгоритма с найденной верхней оценкой $O(n^4)$ семейство функций $O(n^{100})$ тоже будет являться  верхней  оценкой, но  эта  оценка  будет  являться  более слабой.

\begin{tabular}{|p{4.5cm}|p{2.5cm}|p{10cm}|}
    \hline
    \multicolumn{3}{|c|}{Наиболее распространённые значения $O$}\\
    \hline
     Имя&  Нотация&Пример, когда чаще возникает\\
    \hline
    Константная &$O(1)$ &Когда нет необходимости в трудоёмких операциях, таких как перенос данных, балансировка и проч. \textit{Пример:} вставка в связный список.\\
    \hline
    Логарифмическая &$O(log n)$ & Когда удаётся на каждом шаге алгоритма отсекать $\frac{n}{k}$ неподходящих вариантов. \textit{Пример:} бинарный поиск - худший случай(на каждом шаге отсекаем по половине от оставшегося массива), поиск в сбалансированном бинарном дереве (при переходе через один узел точно знаем, что одна из веток нам не подходит, т.е. каждый раз бракуем половинку от оставшихся данных).\\
    \hline
    Линейная &$O(n)$ & Когда необходимо проверить каждый элемент коллекции. Это либо цикл на отрезке $[0;n)$, либо эквивалентная ему рекурсия. \textit{Пример:} линейный обход неотсортированного массива для поиска минимума/максимума.\\
    \hline
    Линейно-логарифмическая &$O(n log n)$ & Возникает в ситуациях с вложенными циклами, в одном из которых можно сделать оптимизацию и постоянно отсевивать по половинке данных. \textit{Пример:} быстрая сортировка.\\
    \hline
    Полиноминальная &$O(n^2)$ & Cитуация вложенных циклов, каждый из которых честно отрабатывает на каждой своей итерации все элементы коллекции. \textit{Пример:} сортировка пузырьком.\\
    \hline
    Экспотенциальная &$O(2^n)$ & \textit{Пример:} алгоритмы перебора - \textit{brute force}.\\
    \hline
    Факториальная &$O(n!)$ & \textit{Пример:} неэффективные комбинаторные алгоритмы по поиску перестановок, размещений, сочетаний и проч.\\
    \hline
\end{tabular}

\subsection{Построение асимптотической оценки}
\begin{enumerate}
    \item Подсчитать максимальное количество элементарных операций, которые совершает алгоритм, в терминах $n$. Построить функцию $f(n)$ количества операций от времени.
    \item Оценить элементарные функции, входящие в $f(n)$: отбрасываем константы, константные множители, элементарные функции, которые являюются бесконечно малыми относительно других элементарных функций при $n \rightarrow \infty$.
    \item Радуемся результату.
\end{enumerate}

\textbf{Примеры на нахождение асимптотических оценок, после которых всё станет ясно:}

Рассмотрим следующий код:
\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{asympt.cpp}

Теперь предположим, что для процессора элементарными являются следующие операции:
\begin{itemize}
    \item Присваивание переменной значения;
    \item Доступ к элементу вектора по индексу;
    \item Сравнение двух чисел;
    \item Инкрементация значения;
    \item Основные арифметические операции.
\end{itemize}
Предположим также, что выбор между $if-else$ происходит мгновенно, время потребляет только проверка на выполняемость условия в $if$.

Теперь разберём код:
\begin{enumerate}
    \item В первой строке мы проводим 2 операции: получаем значение элемента по индексу, присваиваем его переменной - эти операции не зависят от $n$.
    \item Далее выражениям при заходе в цикл (инициализации $i = 0$, сравнению в выражении $i \textless n$) требуется по одной операции. Даже если $n = 0$, эти два выражения сожрут 2 операции.
    \item После захода в цикл каждую итерацию будем так или иначе иметь ещё по две операции: инкремент $++i$ и сравнение $i \textless n$ - они будут давать $+2$ на каждой итерации, $\Rightarrow$ от них будет $2n$ операций.
    \item Теперь получим некоторую функцию времени от входных данных $f(n) = 2n + 4$, где $4 = 2$ операции в первой строке $+ 2$ операции для инициализации цикла. 
    \item В теле цикла мы имеем сравнение в конструкции $if$, которое будет выполняться каждую итерацию, там же мы будем получать $i-ый$ элемента вектора$\Rightarrow$ имеем $+2n$ операций в цикле.
    \item Теперь встаёт вопрос о запуске тела условного оператора: в лучшем случае мы туда даже заходить не будем, в худшем - зайдём $n$ раз и получим каждый раз по 2 операции: вызом по индексу и присваивание, итого имеем $2n$.
    \item Теперь уточним $f(n)$: $f(n) = 4 + 2n + 2n + 0$ для лучшего случая и $f(n) = 4 + 2n + 2n + 2n$ для худшего случая.
\end{enumerate}
Теперь давайте разбираться с функцией в худшем случае:
\begin{enumerate}
    \item При анализе имеет значение только то, как себя ведут самые быстро растущие элементарные функции. Теперь смотрим на нашу: $f(n) = 6n + 4$ - константы при росте $n$ не растут $\Rightarrow$ избавляемся от них и получаем $f(n) = 6n$.
    \item Теперь откинем множитель перед оставшейся элементарной функцией. Себе объясним такую небрежность тем, что мы говорим об абстракции, а в реальности такие множители могут либо раздуваться, либо наоборот исчезать - всё зависит от используемого ЯП. Теперь имеем $f(n) = n$ и, следовательно, $O(f(n)) = O(n)$.
\end{enumerate}

\begin{notice}
    Как видно, мы оценивали здесь \textbf{худший случай}. При оценке лучшего случая, как нетрудно убедиться, мы получим ту же самую оценку, следовательно, можно даже заключить, что в этой ситуации мы имеем оценку времени алгоритма $\theta(n)$.
\end{notice}

Потренируемся находить асимптотики для следующих функций $f(n)$ (они же отображения $f: n\rightarrow t$):
\begin{enumerate}
    \item $f(n) = 5n + 12 \Rightarrow O(f(n)) = n$
    \item $f(n) = 109 \Rightarrow O(f(n)) = 1$ - здесь $109 = 109 * 1$, множитель убираем, а $1$ - элементарная функция наибольшего роста среди оставшихся.
    \item $f(n) = n^3 + 1999n + 1337 \Rightarrow O(f(n)) = n^3$ - если подходить нестрого, скажем, что в любом случае $n^3$ растёт быстрее линейной функции при стремлении к $\infty$. Но мы же математики, поэтому подойдём формально: \large{ $\lim_{n \to \infty} \frac{n^3}{199n} = \infty$}.
\end{enumerate}
Если всё-таки осталось что-то непонятое, рекомендую ознакомиться с этими статьями:

\url{https://habr.com/ru/post/173821/}

\url{https://habr.com/ru/post/196560/}

\subsection{Построение амортизационной оценки}
\begin{notice}
Здесь мы расскажем об алгоритме \textbf{группировки}(ещё называют алгоритмом агрегации). Помимо него есть \textbf{банковский алгоритм} и его обобщение - \textbf{метод потенциалов}. Последние два счастья в рунете изложены сложновато или не до конца полно, а искать на английском в 12 часов ночи уже не хочется.
\end{notice}

\textbf{Алгоритм группировки} состоит в следующем:
\begin{enumerate}
    \item Пусть $t_i$ - реальное время, потраченное на конкретную операцию. Тогда всего времени на $n$ операций было потрачено $\sum\limits_{i = 1}^n (t_i)$ времени.
    \item Теперь поймём, что $\sum\limits_{i = 1}^n (t_i) \geq n$, т.к. $\farall t_i \geq 1$.
    \item Наконец, получим амортизационную оценку: $amort(f(n)) = \frac{\sum\limits_{i = 1}^n (t_i)}{n}$
\end{enumerate}
Поясним на примере:
\begin{problem}
Необходимо найти амортизационную оценку для операции $push\_back$ в вектор, который мы реализовывали в течение семестра.
\end{problem}
\begin{claim}
    Начнём с такого наблюдения: пусть у нас есть изначально пустой вектор и в нём выделена память на 4 элемента.\\
    Первая, вторая, третья, четвёртая операции $push\_back$ выполнятся за $O(1)$. С пятой же операцией мы получим $O(n)$ - она же оценка худшего случая, т.к. в векторе произойдёт перевыделение памяти и перенос старых данных в новый контейнер.\\
    Теперь построим амортизационную оценку:
    $$
    \frac{1+1+1+1+n}{n} = \frac{4 + n}{n} = 1 + \frac{4}{n} \xrightarrow[n\rightarrow\infty]{}1\Rightarrow amort(O(f(n))) = amort(O(1))
    $$
\end{claim}





