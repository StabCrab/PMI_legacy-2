\section{Качественное понимание основ}
\begin{notice}
Не очень понятно, что он имел в виду под этой формулировкой, но из сказанного следует, что, по сути, он может по рандому задать любой из вопросов по материалу, который Макс разбирал на очке. Поэтому данный раздел будет подходить и для ЗРЛ.
\end{notice}
\subsection{ООП}

    \begin{definition}
    \textbf{Объектно-ориентированный подход} - подход, при котором предметная область представлена совокупностью объектов, взаимодействующих между собой с помощью сообщений.
    \end{definition}
    
    \begin{definition}
    \textbf{Предметная область} - множество предметов и условий, в рамках которых происходит работа и выполнение задачи.
    \end{definition}
    \begin{definition}
    \textbf{Объект} - описание сущности из предметной области.
    \end{definition}
    \begin{definition}
    \textbf{Объектно-ориентированное программирование} - методология программирования, основанная на представлении программы в виде совокупности объектов.
    \end{definition}
    \begin{definition}
    \textbf{Класс} - множество объектов, обладающих общими свойствами и поведением.
    \end{definition}

\subsection{Свойства объекта}
    \begin{itemize}
        
        \item \begin{definition}\textbf{Состояние} - каждая уникальная комбинация свойств объекта(атрибутов) и связей с другими объектами. Меняется со временем.
        \end{definition}
        
        \item \begin{definition}\textbf{Поведение} - определяется методами - определяет действия объекта относительно внешних связей и манипуляций с собственными свойствами.
        \end{definition}
        
        \item \begin{definition}\textbf{Идентичность} - свойство объекта, отличающее его ото всех других объектов. \textit{В C++ это адрес}.
        \end{definition}
    \end{itemize}
    
\subsection{Принципы объектной модели}
\textbf{Основные принципы}:
\begin{itemize}
    \item \begin{definition}\textbf{Абстракция} - выделение наиболее существенных характеристик некоторого объекта, отличающих его от всех других объектов, важных с точки зрения дальнейшего рассмотртения.\end{definition}
    \item \begin{definition}\textbf{Инкапсуляция} - отделение друг от друга элементов объекта, определяющих его устройство и поведение. Служит для изоляции абстракции от реализации.\end{definition} 
    \item \begin{definition}\textbf{Модульность} - возможность спроектировать взаимодействия объектов так, чтобы объекты между собой взаимодействовали неинтенсивно, но внутри самих объектов происходила интенсивная работа. \textit{Используется для переиспользования объектов}.\end{definition}
    \item \begin{definition}\textbf{Иерархия} - упорядочивание абстракций по уровням.\end{definition}
\end{itemize}

\textbf{Дополнительные принципы}:
\begin{itemize}
    \item \begin{definition}\textbf{Типизация} - защита от неправильного использования объекта, т.е. от ситуации, когда объект одного класса используется вместо другого.\end{definition}
    \item \begin{definition}\textbf{Устойчивость} - возможность объекта переживать породивший его процесс.\end{definition}
    \item \begin{definition}\textbf{Параллелизм} - наличие в системе нескольких потоков управления одновременно.\end{definition}
\end{itemize}

\subsection{Принципы объектно-ориентированного программирования}
\subsubsection{Сами принципы}
\begin{enumerate}
    \item \textbf{Абстракция} - см. выше.
    \item \textbf{Инкапсуляция} - см. выше.
    \item \begin{definition}\textbf{Наследование} - механизм создания новых объектов на основе уже существующих путём сохранения свойств и поведения с возможностью расширения функциональности и переопределения.\end{definition}
    \item \begin{definition}\textbf{Полиморфизм} - возможность создавать объекты с одинаковым интерфесом и различной реализацией.\end{definition}
\end{enumerate}
\subsubsection{Примеры и особенности реализации принципов инкапсуляции, наследования и полиморфизма в C++}
\paragraph{Инкапсуляция} в C++ реализуется за счёт разделения атрибутов и методов класса(объекта) на публичные, защищённые и скрытые области видимости, реализующиеся с помощью спецификаторов public, protected и private соответственно.

$\qquad$ В листинге ниже представлен класс $Contact$, публичные переменные и методы доступны из основной программы $(main)$. Приватные переменные и методы могут прочитаны, вызваны или изменены только самим классом.Попытка напечатать или изменить приватную переменную $mobile\_number$ из основной программы $(main)$ вызовет ошибку при компиляции потому как доступ к приватным данным в классе ограничен.
\newpage
\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{encapsulation.cpp}
\newpage
\paragraph{Наследование} в C++ подразделяется на публичное$(public)$, защищённое$(protected)$ и приватное$(private)$.

Разница в следующем:
\begin{itemize}
    \item \textbf{Публичное наследование} - публичные и защищённые данные наследуются без изменения доступа к ним. Т.е. если в исходном классе было поле в защищённой области, то и для наследника это поле останется в защищённой области. Если у предка был публичный метод - он останется публичным и у наследника. 
    \item \textbf{Защищённое наследование} - все поля из public и protected родителя становятся protected-полями потомка.
    \item \textbf{Приватное наследование} - поля public и protected предка становятся полями private потомка.
\end{itemize}
\begin{notice}
    \textbf{Private поля предка ни в каком случае не наследуются!}
\end{notice}

Пример приватного наследования:
\lstset{language=C++}
\lstinputlisting[language=C++]{inheritance.cpp}

$\qquad$Класс $Computer$ теперь использует метод $turn\_on()$ как и любой приватный метод: $turn\_on()$ может быть вызван изнутри класса, но попытка вызвать его напрямую из $main$ приведет к ошибке во время компиляции. Для базового класса $Device$, метод $turn\_on()$ остался публичным, и может быть вызван из $main$.

\begin{notice}
    Более подробно о наследовании в C++, порядке вызовов конструкторов и деструкторов, виртуальном наследовании и прочем подробно написано в соответствующем разделе в материалах по \textit{методам и стандартам программирвания}. В этом же разделе приводятся лишь некоторые общетеоретические моменты.
\end{notice}

\paragraph{Полиморфизм} представлен следующими видами: \textbf{параметрический полиморфизм}, \textbf{полиморфизм подтипов}, \textbf{Ad-hoc полиморфизм}, \textbf{полиморфизм приведения к типу}.
\begin{itemize}
    \item \textbf{Параметрический полиморфизм}. Его суть в том, что для различных типов входных данных объект обеспечивает одинаковое поведение. Реализацию этого вида полиморфизма в C++ предлагает механизм шаблонов.
    \item \textbf{Полиморфизм подтипов}. Ситуация, реализуемая через механизм наследования, когда существует базовый тип и несколько его производных; и в базовом, и в производных типах определён один и тот же метод с одинаковой сигнатурой, однако реализация этого метода отличается в зависимости от того, на ком этот метод используется: на базовом типе или на производном (а если на производном, то нужно уточнять, на каком именно).
    
    \textbf{Примером} полиморфизма подтипов может быть следующая ситуация: мы можем создать какой-то базовый тип, который отправляет email-ы, и создать его подтип, который вместо отправки email-ов записывает в лог то что мы хотели отправить, после чего уже отправляет данные дальше другому объекту этого типа.
    \begin{notice}
        Не стоит путать полиморфизм подтипов и наследование. Наследование - всего лишь механизм реализации, тогда как полиморфизм - принцип.
    \end{notice}
    \begin{notice}
        С этим полиморфизмом существует ограничение, связанное с принципами \textbf{SOLID}. А именно: если мы хотим заменить в системе объект какого-то типа на объект подтипа (грубо говоря наследника), то система не должна сломаться. То есть "другое" поведение нашего подтипа должно быть совместимо в плане интерфейса с базовым типом.
    \end{notice}
    
    \item \textbf{Ad-hoc полиморфизм}. Полиморфизм, при котором поведение функции или метода зависит от входных параметров. Говоря совсем грубо, это ситуация, когда есть две функции с одинаковым названием и разными сигнатурами.
    \begin{notice}
        Этот полиморфизм характерен для языков со статической типизацией.
    \end{notice}
    \item \textbf{Полиморфизм приведения к типу}. Возникает в ситуациях, когда мы кастуем объекты производных классов до объектов базового класса, чтобы добиться от них одинакового поведения.
\end{itemize}

$\qquad$ Отличным примером применения полиморфизма является наша с вами лабораторная работа по написанию стека(её ведь все сделали, я надеюсь?). У нас есть абстрактный класс $StackImplementation$, содержащий интерфейс, который должна поддерживать структура, на основе которой работает стек. Уже от этого класса наследуются $VectorStack, ListStack$ - данные классы поддерживают уже реализации на конкретных структурах данных: векторе и списке соответственно. На следующей странице приведены примеры объявления класса $StackImplementation$ и класса $VectorStack$.

Здесь мы видим использование полиморфизма подтипов (наследование $VectorStack$ от $StackImpl$, в результате чего у $VectorStack$ есть своя собственная реализация методов, объявленных родителем), а также параметрического полиморфизма(используем шаблоны).
\begin{notice}
Если бы мы здесь рассматривали реализацию алгоритма сортировочной станции, а именно работу в нём с токенами, то отметили бы, что для их хранения мы используем полиморфизм приведения к типу: все токены мы храним как объекты некоторого $GeneralToken$, и уже при работе программы мы кастуем каждый из них, чтобы конкретизировать их поведение.
\end{notice}

\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{StackImplementation.h}
\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{VectorStack.h}

\newpage

\subsection{Типы отношений объектов}
\begin{definition}
    Отношения - способ организации взаимодействия.
\end{definition}

\subsection{Классификация:}
\begin{itemize}
    \item По виду: одно- и дву- направленные;
    \item По характеру: содержит (\textbf{has-a}), является (\textbf{is-a}), использует (\textbf{uses-a});
    \item По кратности: один на один, один объект на много объектов, много на много...
\end{itemize}

\begin{definition}
    \textbf{Интерфейс} - это контракт с системой, гарантирующий определённое поведение и свойства объекта.
\end{definition}

\subsubsection{Типы отношений:}
\begin{tabular}{|c|p{15cm}|}
\hline
     Зависимость& Она же может считаться конкретизацией поведения.
     Рассматривая на примере: один объект обращается к функции другого.
     При этом объекты \textbf{не являются полями друг друга}
     - отношение $(friend)$. Является однонаправленным отношением.
     \\
\hline
     Часть-целое& \begin{definition}
         \textbf{Агрегация} - целое не управляет жизненным циклом частей.
     \end{definition}
     Пример: работник переживает кампанию. Иными словами, если используем агрегацию, то в деструкторе агрегированный объект не удаляем. \textit{has-a}\\
     \cline{2-2}
     & \begin{definition}
         \textbf{Композиция} - часть принадлжеит только одному объекту, который за неё 'отвечает'.
     \end{definition} Пример: часть удаляется в деструкторе объекта-хозяина, а также находится в приватной части. \textit{has-a}\\
\hline
     Ассоциация& Объекты используют друг друга для своих нужд. Отношения двунаправленные, никто никому не принадлежит. Прекрасный пример: отношения врача и пациента - это явно не отношения часть-целое! У врача спокойно может быть огромное количество пациентов в день, а у пациента своя жизнь с блэкджеком и программированием в задачах радиолокации. \textit{uses-a}\\
\hline
     Наследование& Комментарии тут излишни, всё сказали раньше. \textit{is-a} \\
\hline
\end{tabular}
\begin{notice}
    Примеры на C++ для приведённых выше отношений объектов Вы без проблем можете придумать и сами. Поясним только следующее: пример \textbf{зависимости} мы можем найти, вспомнив класс $MyString$, где нам приходилось делать friend-ом класс 'ostream', чтобы работал корректный вывод; \textbf{часть-целое} - односвязный список - в идеале это композиция, ибо в деструкторе мы разрушаем все node в списке; наследование - очевидный пример со стеком; \textbf{агрегация} - возьмём какой-нибудь класс, который имеет полем $std::string$, получим, что класс не несёт ответственности за жизнь этого поля после себя, при этом это поле может быть передано и другим объектам; \textbf{ассоциация} - один класс запрашивает возвращаемые значения методов другого, чтобы конкретизировать свою работу - на пальцах сказать сложно, но если Вам попадётся код с такими отношениями, Вы сразу поймёте.
\end{notice}
\begin{notice}
    Если у Вас всё хорошо с английским и Вы не поняли того, что написано выше, предлагаю прочитать статью по ссылке:
    
    \url{https://www.learncpp.com/cpp-tutorial/10-1-object-relationships/}
\end{notice}

\subsection{Связь системы и подсистемы}
\begin{notice}
Я в душе не чаю, что имел в виду гений Милонов, когда говорил об этих системах и подсистемах. Тут два варианта: либо он хочет услышать много интересного о теории систем, которой у нас нет, ибо мы не системный анализ и управление; либо он хочет услышать про что-то попроще. Если попроще, предлагаю познакомиться с 5 принципами программирования \textbf{SOLID}. Ниже прикрепляю ссылку.
\end{notice}
\url{https://habr.com/ru/company/mailru/blog/412699/}
